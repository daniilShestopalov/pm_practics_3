# -*- coding: utf-8 -*-
"""Heuristic solution(Менеджмент).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14sLmVGS2fa-cggcpj9Vh720F07u1q3-g
"""

from random import choice
from copy import copy
from typing import Tuple, Callable

def successors_by_predecessors(predecessors: list[list[int]]):
    size = len(predecessors)
    return [[succ for succ in range(size) if i in predecessors[succ]] for i in range(size)]

def calculate_critical_times(
        duration: list[int],
        predecessors: list[list[int]],
        successors: list[list[int]] = None) -> Tuple[list[int], list[int]]:
    """Расчёт ранних времён начала и поздних времён завершения работ

    Args:
        duration (list[int]): _description_
        predecessors (list[list[int]]): списки предшествующих работ
        successors (list[list[int]]): списки последующих работ

    Raises:
        ValueError:

    Returns:
        Tuple[list[int], list[int]]: ранние времена начала и поздние времена завершения
    """
    if not successors:
        successors = successors_by_predecessors(predecessors)
    if len(duration) != len(predecessors) or len(predecessors) != len(successors):
        raise ValueError("Invalid data")
    earliest_start = [0 for _ in duration]
    latest_finish = [0 for _ in duration]

    def _calc_earliest_start(index):
      if predecessors[index]:
          earliest_start[index] = max(_calc_earliest_start(pred) + duration[pred]
                                    for pred in predecessors[index])
      else:
          earliest_start[index] = 0
      return earliest_start[index]

    def _calc_latest_finish(index):
        if index == len(successors) - 1:
            latest_finish[index] = earliest_start[index]
        else:
            latest_finish[index] = min(_calc_latest_finish(succ) - duration[succ] for succ in successors[index])
        return latest_finish[index]

    _calc_earliest_start(len(predecessors) - 1)
    _calc_latest_finish(0)

    return earliest_start, latest_finish

class TimeCapacityNode:
    """
    Вспомогательная структура связного списка моментов времени и
    имеющихся в них остаточных запасов ресурсов
    """
    def __init__(self, time: int, capacity: list[int]):
        self.time = time
        self.capacity = capacity
        self.next = None
        self.prev = None

    def insert_after(self, time: int) -> 'TimeCapacityNode':
        if time <= self.time:
            raise ValueError("Invalid time")

        new_node = self.__class__(time, copy(self.capacity))
        new_node.prev = self
        new_node.next = self.next
        if self.next:
            self.next.prev = new_node
        self.next = new_node
        return new_node

    def find_first(self, time: int) -> 'TimeCapacityNode':
        node = self
        while node.time < time:
            if node.next:
                node = node.next
            else:
                return node
        return node.prev

    def enough_resources(self, demand: list[int]) -> bool:
        return all(self.capacity[i] >= demand[i] for i in range(len(self.capacity)))

    def consume(self, demand: list[int]) -> None:
        for i in range(len(self.capacity)):
            self.capacity[i] -= demand[i]

class ActivityListDecoder:
    def decode(
            self,
            activity_list: list[int],
            duration: list[int],
            predecessors: list[list[int]],
            renewable_demands: list[list[int]],
            renewable_capacity: list[int]) -> list[int]:
        """
        Последовательная схема генерации расписания для декодирования Activity List.

        Args:
            activity_list (list[int]): закодированное решение (Activity List)
            duration (list[int]): продолжительности работ
            predecessors (list[list[int]]): списки предшествующих работ
            renewable_demands (list[list[int]]): затраты неисчерпаемых ресурсов
            renewable_capacity (list[int]): запасы неисчерпаемых ресурсов

        Raises:
            ValueError: выбрасывается при нарушении связей предшествования

        Returns:
            list[int]: времена начала работ
        """
        count = len(activity_list)
        root_node = TimeCapacityNode(0, copy(renewable_capacity)) # Связный список моментов изменения запаса ресурсов
        starts = [0] * count
        finish_nodes = [None] * count
        finish_nodes[0] = root_node

        for i in activity_list:
            # Работа может начаться не раньше, чем её последняя предшественница
            start_node = root_node
            for pred in predecessors[i]:
                if not finish_nodes[pred]:
                    raise ValueError("Invalid activity list")
                if finish_nodes[pred].time > start_node.time:
                    start_node = finish_nodes[pred]
            # Ищем такую позицию для начала, при которой не нарушатся ресурсные ограничения
            start_node, last_node, finish_node, finish_time = self._find_position(
                start_node, duration[i], renewable_demands[i]
            )
            starts[i] = start_node.time
            if not finish_node or finish_node.time != finish_time:
                finish_node = last_node.insert_after(finish_time)
            finish_nodes[i] = finish_node
            # Обновляем доступное число ресурсов в моменты времени, затрагиваемые данной работой
            self._consume(start_node, finish_node, renewable_demands[i])

        return starts

    def _consume(
            self, start_node: TimeCapacityNode,
            finish_node: TimeCapacityNode,
            demand: list[int]) -> None:
        node = start_node
        while node != finish_node:
            node.consume(demand)
            node = node.next

    def _find_position(
            self, start_node: int, duration: int, demand: list[int]
            ) -> Tuple[TimeCapacityNode, TimeCapacityNode, TimeCapacityNode, int]:
        if not duration:
            return (start_node, start_node, start_node, start_node.time)

        finish_time = start_node.time + duration
        t = start_node.find_first(finish_time)
        last_node = t
        t_test = start_node

        while t != t_test.prev:
            if t.enough_resources(demand):
                t = t.prev
            else:
                start_node = t.next
                finish_time = start_node.time + duration
                if last_node.next:
                    t_test = last_node.next
                    last_node = t_test.find_first(finish_time)
                    t = last_node
                else:
                    break

        return (start_node, last_node, last_node.next, finish_time)

class ActivityListactivitySampler:
    def __init__(
            self,
            predecessors: list[list[int]],
            successors: list[list[int]] = None) -> None:
        """
        Args:
            predecessors (list[list[int]]): списки предшествующих работ
            successors (list[list[int]]): списки последующих работ
        """
        self.predecessors = predecessors
        self.size = len(predecessors)
        if not successors:
            successors = successors_by_predecessors(predecessors)
        self.successors = successors

    def _generate(self, func: Callable = None) -> list[int]:
        result = []
        ramain_predecessors = [set(pred) for pred in self.predecessors]
        ready_set = [i for i in range(self.size) if not self.predecessors[i]]

        for _ in range(self.size):
            if not ready_set:
                raise ValueError("Incorrect project network")

            next_activity = func(ready_set) if func else choice(ready_set)
            ready_set.remove(next_activity)
            result.append(next_activity)

            for successor in self.successors[next_activity]:
                ramain_predecessors[successor].remove(next_activity)
                if not ramain_predecessors[successor]:
                    ready_set.append(successor)

        return result

    def generate_random(self) -> list[int]:

        return self._generate()

    def generate_by_max_rule(self, rule: Callable) -> list[int]:

        def func(data: list[int]):
            return max(data, key=rule)
        return self._generate(func)

    def generate_by_min_rule(self, rule: Callable) -> list[int]:

        def func(data: list[int]):
            return min(data, key=rule)
        return self._generate(func)

def generate_random(self) -> list[int]:
        """
        Генерация Activity List случайным образом

        Returns:
            list[int]: Activity List
        """
        return self._generate()

    def generate_by_max_rule(self, rule: Callable) -> list[int]:
        """
        Генерация Activity List упорядочивая по убыванию метрики

        Returns:
            list[int]: Activity List
        """
        def func(data: list[int]):
            return max(data, key=rule)
        return self._generate(func)

    def generate_by_min_rule(self, rule: Callable) -> list[int]:
        """
        Генерация Activity List упорядочивая по возрастанию метрики

        Returns:
            list[int]: Activity List
        """
        def func(data: list[int]):
            return min(data, key=rule)
        return self._generate(func)

time = [5, 4, 7, 5, 6, 8, 5, 6, 7, 5, 5, 4, 4, 6, 4, 4, 8, 6, 5, 6, 5, 4, 3]

res = [
    [0, 4, 4, 6, 0, 0, 8],
    [8, 0, 0, 0, 0, 8, 4],
    [0, 4, 4, 8, 0, 0, 2],
    [8, 6, 6, 0, 2, 0, 0],
    [8, 0, 0, 0, 0, 2, 0],
    [0, 8, 8, 0, 2, 0, 0],
    [4, 6, 6, 0, 2, 0, 0],
    [4, 8, 8, 0, 2, 0, 0],
    [4, 8, 8, 2, 0, 0, 0],
    [2, 8, 8, 0, 2, 0, 0],
    [6, 6, 6, 0, 2, 0, 0],
    [6, 6, 6, 0, 2, 0, 0],
    [6, 6, 6, 0, 2, 0, 0],
    [6, 8, 8, 0, 4, 0, 0],
    [4, 6, 6, 4, 0, 0, 0],
    [4, 6, 6, 0, 2, 0, 0],
    [0, 8, 8, 4, 2, 0, 0],
    [6, 8, 8, 0, 6, 0, 0],
    [4, 6, 6, 0, 8, 0, 0],
    [0, 4, 4, 0, 8, 0, 4],
    [6, 8, 8, 0, 6, 0, 0],
    [6, 4, 4, 0, 4, 6, 0],
    [4, 0, 0, 0, 4, 6, 8],
]

work_day_hours = [8, 8, 8, 8, 8, 8, 8]

predecessors = [
    [],
    [0],
    [0],
    [1, 2],
    [1],
    [3, 4, 2],
    [4, 2],
    [5, 6],
    [4, 2],
    [5, 8],
    [4, 9],
    [4, 9],
    [3, 4],
    [12],
    [9],
    [4],
    [2, 5, 8, 9],
    [7, 10, 11, 13, 14, 15, 16],
    [17],
    [18],
    [19],
    [20],
    [21]
]

successors = successors_by_predecessors(predecessors)

early_start_time, latest_finish_time = calculate_critical_times(time, predecessors, successors)

latest_start_time = [
    latest_finish_time[i] - time[i]
    for i in range(len(time))
]

total_slack = [latest_finish_time[i] - early_start_time[i] - time[i]
               for i in range(len(time))]

float_slack = [(min(early_start_time[succ] for succ in successors[i]) - early_start_time[i] - time[i])
    if successors[i] else 0
    for i in range(len(time))
]

"""**Функции эвристик**"""

# 1. SLK – по возрастанию общего резерва (меньше резерв — выше приоритет)
def rule_slk(i):
    return total_slack[i]  # min_rule (меньший резерв первым)

# 2. FREE – по возрастанию свободного резерва (min(EST_j - EFT_i) для последователей j)
def rule_free(i):
    return float_slack[i]  # min_rule

# 3. LST – по возрастанию позднего времени начала
def rule_lst(i):
    return latest_start_time[i]  # min_rule (раньше дедлайн — выше приоритет)

# 4. LFT – по возрастанию позднего времени завершения
def rule_lft(i):
    return latest_finish_time[i]  # min_rule

# 5. LSTLFT – по возрастанию суммы позднего начала и завершения
def rule_lstlft(i):
    return latest_finish_time[i] + latest_start_time[i]  # min_rule

# 6. GRPW – по убыванию суммарной длительности задачи и её прямых последователей
def rule_grpw(i):
    return time[i] + sum(time[j] for j in successors[i])  # max_rule

# 7. LPT – по убыванию длительности задачи
def rule_lpt(i):
    return time[i]  # max_rule (длинные задачи первыми)

# 8. MIS – по убыванию числа прямых последователей
def rule_mis(i):
    return len(successors[i])  # max_rule (больше последователей — выше приоритет)

# 9. GRD – по убыванию суммарных затрат неисчерпаемых ресурсов
def rule_grd(i):
    return sum(res[i])  # max_rule

# 10. GRWC – по убыванию суммарных затрат ресурсов работы и её прямых последователей
def rule_grwc(i):
    total = sum(res[i])
    for j in successors[i]:
        total += sum(res[j])
    return total  # max_rule

# 11. GCRWC – по убыванию суммарных затрат ресурсов работы и всей цепочки последователей
def rule_gcrwc(i):
    return sum(res[i]) + sum(sum(res[succ]) for succ in successors[i]) # max_rule

# 12. ROT – по убыванию отношения суммарных затрат ресурсов к длительности
def rule_rot(i):
    if time[i] == 0:
        return 0
    res_ratio = sum(res[i][r] / work_day_hours[r] for r in range(len(work_day_hours)) if work_day_hours[r] > 0)
    return res_ratio / time[i]

activity_list_sampler = ActivityListactivitySampler(predecessors, successors)
activity_list__decoder = ActivityListDecoder()

heuristics = [
    ("SLK", rule_slk, "min"),
    ("FREE", rule_free, "min"),
    ("LST", rule_lst, "min"),
    ("LFT", rule_lft, "min"),
    ("LSTLFT", rule_lstlft, "min"),
    ("GRPW", rule_grpw, "max"),
    ("LPT", rule_lpt, "max"),
    ("MIS", rule_mis, "max"),
    ("GRD", rule_grd, "max"),
    ("GRWC", rule_grwc, "max"),
    ("GCRWC", rule_gcrwc, "max"),
    ("ROT", rule_rot, "max"),
]

optimal_schedule = None
minimal_duration = float('inf')
winning_heuristic = ""

methods = {
    "min": activity_list_sampler.generate_by_min_rule,
    "max": activity_list_sampler.generate_by_max_rule
}

for name, func, rule_type in heuristics:
    generate_method = methods[rule_type]
    activity_list = generate_method(func)

    starts = activity_list__decoder.decode(activity_list, time, predecessors, res, work_day_hours)
    makespan = max(starts[i] + time[i] for i in range(len(time)))

    if makespan < minimal_duration:
        minimal_duration = makespan
        optimal_schedule = (starts, activity_list)
        winning_heuristic = name

    print(f"{name:8s}: {makespan:3d} дней")

if optimal_schedule:
    starts, activity_list = optimal_schedule

    print(f"\n{'='*60}")
    print(f"ЛУЧШАЯ ЭВРИСТИКА: {winning_heuristic.upper()}")
    print(f"МИНИМАЛЬНЫЙ СРОК ПРОЕКТА: {minimal_duration} рабочих дней")
    print(f"{'='*60}\n")

    print("ДЕТАЛЬНОЕ РАСПИСАНИЕ ПРОЕКТА (по времени начала):")
    print(f"{'ID':<4} {'Задача':<50} {'Начало':<10} {'Конец':<10} {'Длительность'}")
    print("-" * 90)

    task_names = [
        "Анализ требований и архитектура",
        "Инфраструктура и DevOps",
        "Дизайн-система и прототипы UI",
        "Система авторизации",
        "Модели данных поездок и маршрутов",
        "Экраны создания поездки и точек",
        "Быстрые заметки и голосовые записи",
        "Интеграция галереи и фото",
        "Интерактивная карта маршрута",
        "Редактирование дневника",
        "Раздел статистики и аналитики",
        "Глобальный поиск по поездкам",
        "Публикация и шаринг контента",
        "Публичная лента и взаимодействия",
        "Экспорт дневника в PDF",
        "Список желаний (wishlist)",
        "Финальная верстка экранов",
        "Полная интеграция бэк/фронт",
        "Автоматизированные тесты",
        "Ручное тестирование сценариев",
        "Исправление багов и регрессия",
        "Оптимизация и безопасность",
        "Документация и публикация"
    ]

    # Формируем и сортируем расписание
    schedule = [
        {
            'id': f"{i}",
            'task': task_names[i],
            'start': starts[i],
            'end': starts[i] + time[i],
            'duration': time[i]
        }
        for i in range(len(time))
    ]
    schedule.sort(key=lambda x: x['start'])

    # Выводим таблицу
    for task in schedule:
        print(f"{task['id']:<4} {task['task']:<50} {task['start']:<10} {task['end']:<10} {task['duration']} дн.")

    # Пересчёт в календарное время
    weeks = minimal_duration // 5
    extra_days = minimal_duration % 5
    months = minimal_duration / 22

    print("\n" + "—" * 50)
    print("ПЕРЕСЧЁТ В КАЛЕНДАРНЫЕ СРОКИ:")
    print(f"• Всего рабочих дней:           {minimal_duration}")
    print(f"• Рабочих недель:               {weeks} нед. + {extra_days} дн. (≈ {minimal_duration / 5:.1f} нед.)")
    print(f"• Примерно календарных месяцев:  {months:.1f}")
    print("—" * 50)

    print("\nКЛЮЧЕВЫЕ ВЕХИ ПРОЕКТА:")
    milestones = {
        2:  "Готовность дизайн-системы",
        16: "Завершение верстки всех экранов",
        17: "Завершение полной интеграции бэк/фронт",
        20: "Завершение исправления багов и регрессии",
        21: "Оптимизация и безопасность завершены",
        22: "Релиз MVP (документация и публикация)"
    }

    for idx, desc in milestones.items():
        end_day = starts[idx] + time[idx]
        print(f"• {desc:<50} → день {end_day}")